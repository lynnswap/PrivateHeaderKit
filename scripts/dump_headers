#!/usr/bin/env python3
from __future__ import annotations

import argparse
import atexit
import fcntl
import json
import os
import shutil
import signal
import subprocess
import sys
from collections import deque
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path


@dataclass
class RuntimeInfo:
    version: str
    build: str
    identifier: str
    runtime_root: str


@dataclass
class DeviceInfo:
    name: str
    udid: str
    state: str


@dataclass
class Context:
    exec_mode: str
    classdump_bin: Path
    version: str
    runtime_root: str
    runtime_id: str
    runtime_build: str
    device: DeviceInfo | None
    out_dir: Path
    stage_dir: Path
    skip_existing: bool
    use_shared_cache: bool
    verbose: bool
    layout: str
    categories: list[str]
    framework_names: set[str]
    framework_filters: list[str]


_CLEANUP_PATHS: set[Path] = set()
_CLEANUP_INSTALLED = False
_ACTIVE_PROC: subprocess.Popen | None = None


def register_cleanup(path: Path) -> None:
    global _CLEANUP_INSTALLED
    _CLEANUP_PATHS.add(path)
    if _CLEANUP_INSTALLED:
        return
    _CLEANUP_INSTALLED = True
    atexit.register(run_cleanup)
    install_signal_handlers()


def run_cleanup() -> None:
    for path in list(_CLEANUP_PATHS):
        if not path.exists():
            continue
        if path.is_dir():
            shutil.rmtree(path, ignore_errors=True)
            continue
        try:
            path.unlink()
        except Exception:
            pass


def install_signal_handlers() -> None:
    def handler(_signum, _frame) -> None:
        global _ACTIVE_PROC
        if _ACTIVE_PROC is not None:
            try:
                _ACTIVE_PROC.terminate()
            except Exception:
                pass
        raise KeyboardInterrupt

    for sig in (signal.SIGINT, signal.SIGTERM):
        try:
            signal.signal(sig, handler)
        except Exception:
            continue
    if hasattr(signal, "SIGHUP"):
        try:
            signal.signal(signal.SIGHUP, handler)
        except Exception:
            pass


def build_stage_dir(out_dir: Path) -> Path:
    token = f"{os.getpid()}-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    return out_dir / f".tmp-{token}"


def ensure_device_booted(device: DeviceInfo, *, force: bool = False) -> None:
    if device.state == "Booted" and not force:
        return
    print(f"Booting simulator: {device.name} ({device.udid})")
    run_simple_command(
        "xcrun",
        ["simctl", "boot", device.udid],
        "failed to boot simulator",
    )
    run_simple_command(
        "xcrun",
        ["simctl", "bootstatus", device.udid, "-b"],
        "failed to wait for simulator boot",
    )
    device.state = "Booted"


def acquire_output_lock(out_dir: Path):
    lock_path = out_dir / ".dump_headers.lock"
    lock_file = lock_path.open("a+", encoding="utf-8")
    try:
        fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
    except BlockingIOError as exc:
        lock_file.close()
        raise RuntimeError(f"output directory is locked: {out_dir}") from exc
    lock_file.seek(0)
    lock_file.truncate()
    lock_file.write(
        f"pid={os.getpid()}\nstarted={datetime.now().isoformat(timespec='seconds')}\n"
    )
    lock_file.flush()
    return lock_file


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="dump_headers",
        description="PrivateHeaderKit header dumper (Python)",
    )
    parser.add_argument("version", nargs="?", help="iOS runtime version (e.g. 26.0.1)")
    parser.add_argument("--device", help="Simulator device UDID or name")
    parser.add_argument("--out", type=Path, help="Output directory")
    parser.add_argument(
        "--force",
        action="store_true",
        help="Always dump headers even if they already exist",
    )
    parser.add_argument(
        "--skip-existing",
        action="store_true",
        help=argparse.SUPPRESS,
    )
    parser.add_argument("--exec-mode", choices=["host", "simulator"], help="Force exec mode")
    parser.add_argument("--list-runtimes", action="store_true", help="List runtimes and exit")
    parser.add_argument("--list-devices", action="store_true", help="List devices and exit")
    parser.add_argument("--runtime", help="Runtime version for --list-devices")
    parser.add_argument("--json", action="store_true", help="JSON output for list commands")
    parser.add_argument(
        "--layout",
        choices=["bundle", "headers"],
        help="Output layout (bundle: .framework dirs, headers: plain dirs without suffix)",
    )
    parser.add_argument(
        "--framework",
        action="append",
        help="Exact framework name to dump (repeatable)",
    )
    parser.add_argument(
        "--filter",
        action="append",
        help="Substring filter for framework names (repeatable)",
    )
    parser.add_argument(
        "--shared-cache",
        action="store_true",
        help="Use dyld shared cache when dumping",
    )
    parser.add_argument(
        "--clean-build",
        "--cleanbuild",
        "--rebuild",
        "--rebuild-classdump",
        action="store_true",
        dest="rebuild_classdump",
        help="Clear .build and rebuild classdump-dyld",
    )
    parser.add_argument(
        "-D",
        "--verbose",
        action="store_true",
        help="Enable verbose logging in classdump-dyld",
    )

    args = parser.parse_args()

    ctx: Context | None = None
    lock_file = None
    try:
        if args.list_runtimes:
            list_runtimes_command(args.json)
            return 0
        if args.list_devices:
            list_devices_command(args.runtime, args.json)
            return 0

        root_dir = find_root_dir()
        rebuild_classdump = resolve_rebuild_classdump(args)
        if rebuild_classdump:
            clear_build_artifacts(root_dir)
        classdump_host, classdump_simulator, classdump_sim = classdump_paths(root_dir)

        requested_exec_mode = args.exec_mode or os.getenv("PH_EXEC_MODE")
        auto_exec_mode = requested_exec_mode is None
        exec_mode = resolve_exec_mode(
            requested_exec_mode,
            classdump_host,
            classdump_simulator,
            classdump_sim,
        )

        categories, framework_names, framework_filters = build_selection(args)
        layout = resolve_layout(args.layout)
        use_shared_cache = resolve_shared_cache(args)
        verbose = resolve_verbose(args)

        def setup_context(exec_mode: str) -> Context:
            classdump_bin = (
                classdump_host
                if exec_mode == "host"
                else (classdump_simulator if classdump_simulator.is_file() else classdump_sim)
            )
            if args.version:
                ctx = non_interactive_setup(
                    root_dir,
                    classdump_bin,
                    exec_mode,
                    args,
                    categories,
                    framework_names,
                    framework_filters,
                    layout,
                    use_shared_cache,
                    verbose,
                )
            else:
                ctx = interactive_setup(
                    root_dir,
                    classdump_bin,
                    exec_mode,
                    args,
                    categories,
                    framework_names,
                    framework_filters,
                    layout,
                    use_shared_cache,
                    verbose,
                )

            ctx.classdump_bin = ensure_classdump_binary(
                root_dir,
                ctx,
                rebuild_classdump=rebuild_classdump
            )

            if ctx.exec_mode == "simulator":
                device = ctx.device
                if device is None:
                    raise RuntimeError("no simulator device available")
                ensure_device_booted(device)
            return ctx

        try:
            ctx = setup_context(exec_mode)
        except RuntimeError as exc:
            if auto_exec_mode and exec_mode == "simulator" and should_fallback_to_host(exc):
                print(f"Simulator unavailable; falling back to host: {exc}", file=sys.stderr)
                exec_mode = "host"
                ctx = setup_context(exec_mode)
            else:
                raise

        ctx.out_dir.mkdir(parents=True, exist_ok=True)
        lock_file = acquire_output_lock(ctx.out_dir)
        register_cleanup(ctx.out_dir / ".dump_headers.lock")
        register_cleanup(ctx.stage_dir)
        prepare_output_layout(ctx)

        for category in ctx.categories:
            reset_stage_dir(ctx)
            had_failures = dump_category(category, ctx)
            finalize_category_output(ctx, category, had_failures)

        write_metadata(ctx)
        print(f"Done: {ctx.out_dir}")
        return 0
    except KeyboardInterrupt:
        print("Interrupted", file=sys.stderr)
        return 130
    except RuntimeError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return 1
    finally:
        if lock_file is not None:
            lock_file.close()
        if ctx is not None:
            run_cleanup()


def resolve_exec_mode(
    requested: str | None, classdump_host: Path, classdump_simulator: Path, classdump_sim: Path
) -> str:
    if requested in ("host", "simulator"):
        return requested
    try:
        if list_runtimes():
            return "simulator"
    except Exception:
        pass
    if classdump_host.is_file():
        return "host"
    if classdump_simulator.is_file() or classdump_sim.is_file():
        return "simulator"
    return "host"


def should_fallback_to_host(exc: RuntimeError) -> bool:
    message = str(exc).lower()
    if "no available ios runtimes found" in message:
        return False
    if "ios runtime not found or unavailable" in message:
        return False
    fallback_tokens = (
        "no simulator device available",
        "no simulator device found",
        "failed to create simulator device",
        "failed to boot simulator",
        "failed to wait for simulator boot",
        "failed to build classdump-dyld for ios simulator",
        "no simulator device available for classdump-dyld build",
    )
    return any(token in message for token in fallback_tokens)


def resolve_layout(requested: str | None) -> str:
    layout = (requested or os.getenv("PH_LAYOUT") or "headers").strip().lower()
    if layout not in ("bundle", "headers"):
        raise RuntimeError(f"invalid layout: {layout}")
    return layout


def build_selection(args) -> tuple[list[str], set[str], list[str]]:
    categories = ["Frameworks", "PrivateFrameworks"]

    framework_names = set()
    if args.framework:
        for name in args.framework:
            normalized = normalize_framework_name(name)
            framework_names.add(normalized.lower())

    framework_filters = []
    if args.filter:
        framework_filters = [f.lower() for f in args.filter if f.strip()]

    return categories, framework_names, framework_filters


def list_runtimes_command(json_output: bool) -> None:
    runtimes = list_runtimes()
    if json_output:
        payload = [
            {
                "version": r.version,
                "build": r.build,
                "identifier": r.identifier,
                "runtime_root": r.runtime_root,
            }
            for r in runtimes
        ]
        print(json.dumps(payload, indent=2))
        return
    print("Available iOS runtimes:")
    for idx, runtime in enumerate(runtimes, start=1):
        print(f"  [{idx}] iOS {runtime.version} ({runtime.build})")
        print(f"      {runtime.identifier}")
        print(f"      {runtime.runtime_root}")


def list_devices_command(version: str | None, json_output: bool) -> None:
    runtime = find_runtime(version) if version else latest_runtime()
    devices = list_devices(runtime.identifier)
    if json_output:
        payload = {
            "runtime": {
                "version": runtime.version,
                "build": runtime.build,
                "identifier": runtime.identifier,
                "runtime_root": runtime.runtime_root,
            },
            "devices": [
                {
                    "name": d.get("name", "") or "",
                    "udid": d.get("udid", "") or "",
                    "state": d.get("state", "") or "",
                }
                for d in devices
            ],
        }
        print(json.dumps(payload, indent=2))
        return
    print(f"Devices for iOS {runtime.version} ({runtime.build}):")
    print(f"  {runtime.identifier}")
    for idx, d in enumerate(devices, start=1):
        name = d.get("name", "") or ""
        state = d.get("state", "") or ""
        udid = d.get("udid", "") or ""
        print(f"  [{idx}] {name} ({state})")
        print(f"      {udid}")


def classdump_paths(root_dir: Path) -> tuple[Path, Path, Path]:
    classdump_host = root_dir / ".build" / "debug" / "classdump-dyld"
    classdump_simulator = (
        root_dir
        / ".build"
        / "DerivedData"
        / "Build"
        / "Products"
        / "Debug-iphonesimulator"
        / "classdump-dyld"
    )
    classdump_sim = root_dir / ".build" / "Debug-iphoneos" / "classdump-dyld"
    return classdump_host, classdump_simulator, classdump_sim


def clear_build_artifacts(root_dir: Path) -> None:
    build_dir = root_dir / ".build"
    if not build_dir.exists():
        return
    print("Clearing build artifacts: .build")
    shutil.rmtree(build_dir, ignore_errors=True)


def classdump_source_present(root_dir: Path) -> bool:
    return (root_dir / "Package.swift").is_file()


def classdump_binaries_present(root_dir: Path) -> bool:
    return any(path.is_file() for path in classdump_paths(root_dir))


def find_root_dir() -> Path:
    candidates = [Path(__file__).resolve().parent, Path.cwd()]
    for start in candidates:
        current = start
        while True:
            if classdump_binaries_present(current) or classdump_source_present(current):
                return current
            if current.parent == current:
                break
            current = current.parent
    raise RuntimeError("repository root not found (Package.swift missing)")


def build_classdump_host(root_dir: Path) -> Path:
    print("Building classdump-dyld for host (SwiftPM)...")
    run_simple_command(
        "swift",
        ["build", "-c", "debug", "--product", "classdump-dyld"],
        "failed to build classdump-dyld for host",
        cwd=root_dir,
    )
    bin_path = root_dir / ".build" / "debug" / "classdump-dyld"
    if not bin_path.is_file():
        raise RuntimeError("classdump-dyld host build output not found")
    return bin_path


def build_classdump_simulator(root_dir: Path, device: DeviceInfo) -> Path:
    derived_data = root_dir / ".build" / "DerivedData"
    print("Building classdump-dyld for iOS Simulator (SwiftPM)...")
    scheme = os.getenv("PH_XCODE_SCHEME") or "PrivateHeaderKit"
    run_simple_command(
        "xcodebuild",
        [
            "-scheme",
            scheme,
            "-configuration",
            "Debug",
            "-destination",
            f"id={device.udid}",
            "-derivedDataPath",
            str(derived_data),
            "-skipMacroValidation",
            "-skipPackagePluginValidation",
        ],
        "failed to build classdump-dyld for iOS Simulator",
        cwd=root_dir,
    )
    bin_path = derived_data / "Build" / "Products" / "Debug-iphonesimulator" / "classdump-dyld"
    if not bin_path.is_file():
        raise RuntimeError("classdump-dyld simulator build output not found")
    return bin_path


def ensure_classdump_binary(
    root_dir: Path,
    ctx: Context,
    rebuild_classdump: bool
) -> Path:
    classdump_host, classdump_simulator, classdump_sim = classdump_paths(root_dir)
    if rebuild_classdump:
        if ctx.exec_mode == "host":
            try_remove_file(classdump_host)
        else:
            try_remove_file(classdump_simulator)
            try_remove_file(classdump_sim)
    if ctx.exec_mode == "host":
        if classdump_host.is_file():
            return classdump_host
        return build_classdump_host(root_dir)
    if classdump_simulator.is_file():
        return classdump_simulator
    if classdump_sim.is_file():
        return classdump_sim
    if ctx.device is None:
        raise RuntimeError("no simulator device available for classdump-dyld build")
    return build_classdump_simulator(root_dir, ctx.device)


def interactive_setup(
    root_dir: Path,
    classdump_bin: Path,
    exec_mode: str,
    args,
    categories: list[str],
    framework_names: set[str],
    framework_filters: list[str],
    layout: str,
    use_shared_cache: bool,
    verbose: bool,
) -> Context:
    print("Interactive mode")
    runtimes = list_runtimes()
    if not runtimes:
        raise RuntimeError("no available iOS runtimes found")
    runtime = pick_runtime_interactive(runtimes)

    device = None
    if exec_mode == "simulator":
        devices = list_devices(runtime.identifier)
        if not devices:
            print(f"No devices available for runtime: {runtime.identifier}")
            create_default_device(runtime.identifier, runtime.version)
            devices = list_devices(runtime.identifier)
            if not devices:
                raise RuntimeError(
                    f"failed to create simulator device for runtime: {runtime.identifier}"
                )
        print_devices(devices)
        if args.device:
            device = match_device(devices, args.device)
            if device is None:
                raise RuntimeError(f"no simulator device found for runtime: {runtime.identifier}")
        else:
            device = resolve_default_device(runtime, devices)

    default_out = root_dir / "generated-headers/iOS" / runtime.version
    out_dir = (
        args.out
        or Path(os.getenv("PH_OUT_DIR")) if os.getenv("PH_OUT_DIR") else None
    ) or default_out
    stage_dir = build_stage_dir(out_dir)
    skip_existing = resolve_skip_existing(args)

    if device:
        print(f"Using device: {device.name} ({device.state})")
    print(f"Output directory: {out_dir}")

    return Context(
        exec_mode=exec_mode,
        classdump_bin=classdump_bin.resolve(),
        version=runtime.version,
        runtime_root=runtime.runtime_root,
        runtime_id=runtime.identifier,
        runtime_build=runtime.build,
        device=device,
        out_dir=out_dir.resolve(),
        stage_dir=stage_dir.resolve(),
        skip_existing=skip_existing,
        use_shared_cache=use_shared_cache,
        verbose=verbose,
        layout=layout,
        categories=categories,
        framework_names=framework_names,
        framework_filters=framework_filters,
    )


def non_interactive_setup(
    root_dir: Path,
    classdump_bin: Path,
    exec_mode: str,
    args,
    categories: list[str],
    framework_names: set[str],
    framework_filters: list[str],
    layout: str,
    use_shared_cache: bool,
    verbose: bool,
) -> Context:
    version = args.version or ""
    runtime = find_runtime(version)

    device = None
    if exec_mode == "simulator":
        devices = list_devices(runtime.identifier)
        if not devices:
            create_default_device(runtime.identifier, runtime.version)
            devices = list_devices(runtime.identifier)
        if not devices:
            raise RuntimeError(f"no simulator device found for runtime: {runtime.identifier}")
        if args.device:
            device = match_device(devices, args.device)
            if device is None:
                raise RuntimeError(f"no simulator device found for runtime: {runtime.identifier}")
        else:
            device = resolve_default_device(runtime, devices)

    out_dir = args.out or root_dir / "generated-headers/iOS" / version
    stage_dir = build_stage_dir(out_dir)
    skip_existing = resolve_skip_existing(args)

    return Context(
        exec_mode=exec_mode,
        classdump_bin=classdump_bin.resolve(),
        version=version,
        runtime_root=runtime.runtime_root,
        runtime_id=runtime.identifier,
        runtime_build=runtime.build,
        device=device,
        out_dir=out_dir.resolve(),
        stage_dir=stage_dir.resolve(),
        skip_existing=skip_existing,
        use_shared_cache=use_shared_cache,
        verbose=verbose,
        layout=layout,
        categories=categories,
        framework_names=framework_names,
        framework_filters=framework_filters,
    )


def list_runtimes() -> list[RuntimeInfo]:
    output = run_capture_command("xcrun", ["simctl", "list", "runtimes", "-j"])
    data = json.loads(output)
    runtimes = []
    for entry in data.get("runtimes", []):
        name = entry.get("name") or ""
        if not name.startswith("iOS"):
            continue
        if not entry.get("isAvailable", False):
            continue
        version = entry.get("version") or ""
        identifier = entry.get("identifier") or ""
        runtime_root = entry.get("runtimeRoot") or ""
        if not version or not identifier or not runtime_root:
            continue
        build = entry.get("buildversion") or ""
        runtimes.append(
            RuntimeInfo(
                version=version,
                build=build,
                identifier=identifier,
                runtime_root=runtime_root,
            )
        )
    runtimes.sort(key=lambda r: version_key(r.version))
    return runtimes


def pick_runtime_interactive(runtimes: list[RuntimeInfo]) -> RuntimeInfo:
    print("Available iOS runtimes:")
    for idx, runtime in enumerate(runtimes, start=1):
        print(f"  [{idx}] iOS {runtime.version} ({runtime.build})")
    default_index = len(runtimes)
    choice = read_line("Select runtime (Enter for latest): ")
    if not choice:
        return runtimes[default_index - 1]
    try:
        idx = int(choice)
    except ValueError as exc:
        raise RuntimeError("invalid selection") from exc
    if idx <= 0 or idx > len(runtimes):
        raise RuntimeError("invalid selection")
    return runtimes[idx - 1]


def find_runtime(version: str) -> RuntimeInfo:
    for runtime in list_runtimes():
        if runtime.version == version:
            return runtime
    raise RuntimeError(f"iOS runtime not found or unavailable: {version}")


def latest_runtime() -> RuntimeInfo:
    runtimes = list_runtimes()
    if not runtimes:
        raise RuntimeError("no available iOS runtimes found")
    return runtimes[-1]


def list_devices(runtime_id: str) -> list[dict]:
    output = run_capture_command("xcrun", ["simctl", "list", "devices", "-j"])
    data = json.loads(output)
    return list(data.get("devices", {}).get(runtime_id, []))


def match_device(devices: list[dict], query: str) -> DeviceInfo | None:
    needle = query.lower()
    for d in devices:
        udid = (d.get("udid") or "").lower()
        if udid == needle:
            return DeviceInfo(
                name=d.get("name") or "",
                udid=d.get("udid") or "",
                state=d.get("state") or "",
            )
    for d in devices:
        name = (d.get("name") or "").lower()
        if name == needle:
            return DeviceInfo(
                name=d.get("name") or "",
                udid=d.get("udid") or "",
                state=d.get("state") or "",
            )
    return None


def pick_default_device(devices: list[dict]) -> DeviceInfo:
    for d in devices:
        if d.get("state") == "Booted":
            return DeviceInfo(
                name=d.get("name") or "",
                udid=d.get("udid") or "",
                state=d.get("state") or "",
            )
    first = devices[0]
    return DeviceInfo(
        name=first.get("name") or "",
        udid=first.get("udid") or "",
        state=first.get("state") or "",
    )


def default_clone_name(version: str) -> str:
    return f"Dumping Device (iOS {version})"


def clone_device(base: DeviceInfo, runtime_id: str, clone_name: str) -> DeviceInfo:
    print(f"Cloning simulator: {base.name} -> {clone_name}")
    output = run_capture_command("xcrun", ["simctl", "clone", base.udid, clone_name])
    udid = ""
    for line in reversed(output.splitlines()):
        candidate = line.strip()
        if candidate:
            udid = candidate
            break
    if not udid:
        devices = list_devices(runtime_id)
        clone = match_device(devices, clone_name)
        if clone:
            return clone
        raise RuntimeError("failed to determine cloned simulator udid")
    return DeviceInfo(name=clone_name, udid=udid, state="Shutdown")


def resolve_default_device(runtime: RuntimeInfo, devices: list[dict]) -> DeviceInfo:
    clone_name = default_clone_name(runtime.version)
    clone = match_device(devices, clone_name)
    if clone:
        return clone
    base = pick_default_device(devices)
    if base.name == clone_name:
        return base
    return clone_device(base, runtime.identifier, clone_name)


def print_devices(devices: list[dict]) -> None:
    print("Devices:")
    for idx, d in enumerate(devices, start=1):
        name = d.get("name") or ""
        state = d.get("state") or ""
        print(f"  [{idx}] {name} ({state})")


def create_default_device(runtime_id: str, version: str) -> None:
    output = run_capture_command("xcrun", ["simctl", "list", "devicetypes", "-j"])
    data = json.loads(output)
    device_types = data.get("devicetypes", [])
    choice = None
    env_device_type = (os.getenv("PH_DEVICE_TYPE") or "").strip()
    if env_device_type:
        for entry in device_types:
            if entry.get("identifier") == env_device_type or entry.get("name") == env_device_type:
                choice = entry
                break
        if choice is None:
            env_lower = env_device_type.lower()
            for entry in device_types:
                if (entry.get("identifier") or "").lower() == env_lower:
                    choice = entry
                    break
                if (entry.get("name") or "").lower() == env_lower:
                    choice = entry
                    break
        if choice is None:
            raise RuntimeError(f"device type not found: {env_device_type}")
    if choice is None:
        for entry in device_types:
            if entry.get("productFamily") == "iPhone":
                choice = entry
                break
    if choice is None:
        for entry in device_types:
            if (entry.get("name") or "").startswith("iPhone"):
                choice = entry
                break
    if not choice:
        raise RuntimeError("no device types available")
    device_name = choice.get("name") or ""
    device_type = choice.get("identifier") or ""
    if not device_name or not device_type:
        raise RuntimeError("failed to resolve device type for creation")
    created_name = f"{device_name} ({version})"
    print(f"Creating device: {created_name}")
    run_simple_command(
        "xcrun",
        ["simctl", "create", created_name, device_type, runtime_id],
        "failed to create simulator device",
    )


def dump_category(category: str, ctx: Context) -> bool:
    print(f"Dumping: {category}")
    if needs_split(ctx):
        return dump_category_split(category, ctx)
    status, killed, last_lines = run_classdump(category, ctx)
    if killed:
        print("Retrying per-framework to avoid simulator kill.")
        reset_stage_dir(ctx)
        return dump_category_split(category, ctx)
    if status != 0:
        report_last_lines(last_lines)
        raise RuntimeError(f"classdump-dyld failed for {category}")
    return False


def dump_category_split(category: str, ctx: Context) -> bool:
    frameworks = list_frameworks(category, ctx)
    if not frameworks:
        print(f"Skipping {category}: no frameworks found under /System/Library/{category}")
        return False
    failures = []
    total = len(frameworks)
    existing = set()
    if ctx.skip_existing:
        existing = existing_frameworks_in_category(ctx, category, set(frameworks))
    for idx, item in enumerate(frameworks, start=1):
        if ctx.skip_existing and item in existing:
            print(f"Skipping existing: {category} ({idx}/{total}) {item}")
            continue
        print(f"Dumping: {category} ({idx}/{total}) {item}")
        path = f"{category}/{item}"
        status, killed, last_lines = run_classdump(path, ctx)
        if killed or status != 0:
            report_last_lines(last_lines)
            failures.append(path)
        else:
            relocate_framework_output(ctx, category, item)
            if ctx.layout == "headers":
                normalize_framework_dir(ctx, category, item)
    had_failures = bool(failures)
    if had_failures:
        summary = f"classdump-dyld failed for {len(failures)} items under {category}"
        print(summary, file=sys.stderr)
        write_failures(ctx, summary, failures)
    return had_failures


def stage_system_library_roots(ctx: Context) -> list[Path]:
    roots = [ctx.stage_dir / "System" / "Library"]
    try:
        runtime_root = Path(ctx.runtime_root)
        if runtime_root.is_absolute():
            rel_root = runtime_root.relative_to("/")
            roots.append(ctx.stage_dir / rel_root / "System" / "Library")
    except Exception:
        pass
    unique: list[Path] = []
    for root in roots:
        if root not in unique:
            unique.append(root)
    return unique


def relocate_framework_output(ctx: Context, category: str, framework_name: str) -> None:
    src = None
    for base in stage_system_library_roots(ctx):
        candidate = base / category / framework_name
        if candidate.exists() and not candidate.is_symlink():
            src = candidate
            break
    if src is None:
        return
    dest_dir = ctx.out_dir / category
    dest_dir.mkdir(parents=True, exist_ok=True)
    dest = dest_dir / framework_name
    if dest.exists():
        merge_directories(src, dest)
        try_remove_empty(src)
    else:
        shutil.move(str(src), str(dest))


def relocate_frameworks_in_category(ctx: Context, category: str) -> None:
    dest_dir = ctx.out_dir / category
    dest_dir.mkdir(parents=True, exist_ok=True)
    for base in stage_system_library_roots(ctx):
        src_dir = base / category
        if not src_dir.is_dir() or src_dir.is_symlink():
            continue
        for entry in src_dir.iterdir():
            if entry.is_symlink():
                continue
            dest = dest_dir / entry.name
            if dest.exists():
                if entry.is_dir():
                    merge_directories(entry, dest)
                    try_remove_empty(entry)
                else:
                    entry.unlink()
            else:
                shutil.move(str(entry), str(dest))


def prepare_output_layout(ctx: Context) -> None:
    for category in ctx.categories:
        if ctx.layout == "headers":
            normalize_framework_dirs(ctx, category)
        else:
            denormalize_framework_dirs(ctx, category)


def reset_stage_dir(ctx: Context) -> None:
    if ctx.stage_dir.exists():
        shutil.rmtree(ctx.stage_dir)
    ctx.stage_dir.mkdir(parents=True, exist_ok=True)


def finalize_category_output(ctx: Context, category: str, had_failures: bool = False) -> None:
    if not had_failures:
        relocate_frameworks_in_category(ctx, category)
    if ctx.layout == "headers":
        normalize_framework_dirs(ctx, category)


def normalize_framework_dirs(ctx: Context, category: str) -> None:
    base = ctx.out_dir / category
    if not base.is_dir():
        return
    framework_ext = ".framework"
    entries = list(base.iterdir())
    for entry in entries:
        if entry.is_symlink() and entry.name.endswith(framework_ext):
            entry.unlink()
    for entry in entries:
        if entry.is_symlink():
            continue
        if not entry.is_dir():
            continue
        if not entry.name.endswith(framework_ext):
            continue
        framework_name = entry.name
        target_name = framework_name[: -len(framework_ext)]
        target = base / target_name
        if target.exists():
            if target.is_symlink():
                target.unlink()
            if target.exists():
                merge_directories(entry, target)
                try_remove_empty(entry)
            else:
                entry.rename(target)
        else:
            entry.rename(target)


def normalize_framework_dir(ctx: Context, category: str, framework_name: str) -> None:
    base = ctx.out_dir / category
    if not base.is_dir():
        return
    framework_ext = ".framework"
    if not framework_name.endswith(framework_ext):
        return
    entry = base / framework_name
    if entry.is_symlink() or not entry.is_dir():
        return
    target = base / framework_name[: -len(framework_ext)]
    if target.exists():
        if target.is_symlink():
            target.unlink()
        if target.exists():
            merge_directories(entry, target)
            try_remove_empty(entry)
        else:
            entry.rename(target)
    else:
        entry.rename(target)


def denormalize_framework_dirs(ctx: Context, category: str) -> None:
    base = ctx.out_dir / category
    if not base.is_dir():
        return
    framework_ext = ".framework"
    entries = list(base.iterdir())
    for entry in entries:
        if entry.is_symlink() and entry.name.endswith(framework_ext):
            entry.unlink()
    for entry in list(base.iterdir()):
        if entry.is_symlink() or not entry.is_dir():
            continue
        if entry.name.endswith(framework_ext):
            continue
        dest = base / f"{entry.name}{framework_ext}"
        if dest.exists():
            if dest.is_symlink():
                dest.unlink()
            if dest.exists():
                merge_directories(entry, dest)
                try_remove_empty(entry)
            else:
                entry.rename(dest)
        else:
            entry.rename(dest)


def run_classdump(category: str, ctx: Context) -> tuple[int, bool, list[str]]:
    if ctx.exec_mode == "host":
        return run_classdump_host(category, ctx)
    return run_classdump_simulator(category, ctx)


def run_classdump_host(category: str, ctx: Context) -> tuple[int, bool, list[str]]:
    source_path = Path(ctx.runtime_root) / "System/Library" / category
    is_recursive = "/" not in category
    cmd = [str(ctx.classdump_bin), "-o", str(ctx.stage_dir)]
    if is_recursive:
        cmd += ["-r", str(source_path)]
    else:
        cmd.append(str(source_path))
    cmd += ["-b", "-h"]
    if ctx.verbose:
        cmd.append("-D")
    if ctx.skip_existing:
        cmd.append("-s")
    env = None
    if ctx.use_shared_cache:
        cmd.append("-c")
        env = os.environ.copy()
        env["SIMCTL_CHILD_DYLD_ROOT_PATH"] = ctx.runtime_root
    return run_command_stream(cmd, env=env)


def run_classdump_simulator(category: str, ctx: Context) -> tuple[int, bool, list[str]]:
    device = ctx.device
    if device is None:
        raise RuntimeError("no simulator device available")
    source_path = f"/System/Library/{category}"
    is_recursive = "/" not in category
    cmd = [
        "xcrun",
        "simctl",
        "spawn",
        device.udid,
        str(ctx.classdump_bin),
        "-o",
        str(ctx.stage_dir),
    ]
    if is_recursive:
        cmd += ["-r", source_path]
    else:
        cmd.append(source_path)
    cmd += ["-b", "-h"]
    if ctx.verbose:
        cmd.append("-D")
    if ctx.skip_existing:
        cmd.append("-s")
    if ctx.use_shared_cache:
        cmd.append("-c")
    env = os.environ.copy()
    env["SIMCTL_CHILD_PH_RUNTIME_ROOT"] = ctx.runtime_root
    env["SIMCTL_CHILD_DYLD_ROOT_PATH"] = ctx.runtime_root
    status, killed, last_lines = run_command_stream(cmd, env=env)
    if status != 0 and should_retry_simulator_boot(last_lines):
        ensure_device_booted(device, force=True)
        status, killed, last_lines = run_command_stream(cmd, env=env)
    return status, killed, last_lines


def should_retry_simulator_boot(last_lines: list[str]) -> bool:
    for line in last_lines:
        lowered = line.lower()
        if "device is not booted" in lowered:
            return True
        if "bad or unknown session" in lowered:
            return True
    return False


def run_command_stream(cmd: list[str], env: dict | None = None) -> tuple[int, bool, list[str]]:
    global _ACTIVE_PROC
    proc = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        env=env,
        bufsize=1,
    )
    _ACTIVE_PROC = proc
    last_lines: deque[str] = deque(maxlen=8)
    killed = False
    try:
        if proc.stdout:
            for line in proc.stdout:
                line = line.rstrip()
                if line:
                    print(line, flush=True)
                    last_lines.append(line)
                    if "Killed: 9" in line or "killed: 9" in line:
                        killed = True
        returncode = proc.wait()
        if returncode < 0:
            killed = True
            last_lines.append(f"Terminated by signal {-returncode}")
        elif returncode != 0 and not last_lines:
            last_lines.append(f"Exited with status {returncode}")
        return returncode, killed, list(last_lines)
    except KeyboardInterrupt:
        try:
            proc.terminate()
        except Exception:
            pass
        try:
            proc.wait(timeout=5)
        except Exception:
            try:
                proc.kill()
            except Exception:
                pass
            try:
                proc.wait(timeout=5)
            except Exception:
                pass
        raise
    finally:
        _ACTIVE_PROC = None


def report_last_lines(lines: list[str]) -> None:
    if not lines:
        return
    print("--- last output ---", file=sys.stderr)
    for line in lines:
        print(line, file=sys.stderr)


def write_failures(ctx: Context, summary: str, failures: list[str]) -> None:
    path = ctx.out_dir / "_failures.txt"
    with path.open("a", encoding="utf-8") as f:
        f.write(f"{summary}:\n")
        for item in failures:
            f.write(f"  - {item}\n")


def write_metadata(ctx: Context) -> None:
    header_count = count_headers(ctx.out_dir)
    try:
        xcode = run_capture_command("xcodebuild", ["-version"]).splitlines()
        xcode_info = " ".join(xcode)
    except RuntimeError:
        xcode_info = "unknown"
    generated_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S %Z")
    skip = "-s" if ctx.skip_existing else ""
    metadata = (
        f"Generated: {generated_at}\n"
        f"RuntimeRoot: {ctx.runtime_root}\n"
        f"RuntimeIdentifier: {ctx.runtime_id}\n"
        f"RuntimeBuild: {ctx.runtime_build}\n"
        f"iOS: {ctx.version}\n"
        f"HeadersPath: {ctx.out_dir}\n"
        f"Layout: {ctx.layout}\n"
        f"HeaderCount: {header_count}\n"
        f"Xcode: {xcode_info}\n"
        f"Notes: classdump-dyld output; /System/Library/{{Frameworks,PrivateFrameworks}}; -b -h {skip}\n"
    )
    path = ctx.out_dir / "_metadata.txt"
    path.write_text(metadata, encoding="utf-8")


def count_headers(dir_path: Path) -> int:
    count = 0
    for root, dirs, files in os.walk(dir_path):
        dirs[:] = [name for name in dirs if not name.startswith(".tmp")]
        if os.path.basename(root).startswith(".tmp"):
            continue
        for name in files:
            if name.endswith(".h"):
                count += 1
    return count


def list_frameworks(category: str, ctx: Context) -> list[str]:
    dir_path = Path(ctx.runtime_root) / "System/Library" / category
    if not dir_path.is_dir():
        raise RuntimeError(f"failed to read {dir_path}")
    frameworks = [p.name for p in dir_path.iterdir() if p.name.endswith(".framework")]
    frameworks.sort()
    frameworks = filter_frameworks(frameworks, ctx)
    return frameworks


def existing_frameworks_in_category(
    ctx: Context, category: str, frameworks: set[str]
) -> set[str]:
    category_dir = ctx.out_dir / category
    if not category_dir.is_dir():
        return set()
    existing: set[str] = set()
    for root, dirs, files in os.walk(category_dir):
        dirs[:] = [name for name in dirs if not name.startswith(".tmp")]
        if not files:
            continue
        if not any(name.endswith(".h") for name in files):
            continue
        rel = Path(root).relative_to(category_dir)
        if not rel.parts:
            continue
        top = rel.parts[0]
        framework_name = normalize_framework_name(top) if ctx.layout == "headers" else top
        if framework_name in frameworks:
            existing.add(framework_name)
    return existing


def filter_frameworks(frameworks: list[str], ctx: Context) -> list[str]:
    filtered = frameworks
    if ctx.framework_names:
        filtered = [f for f in filtered if f.lower() in ctx.framework_names]
    if ctx.framework_filters:
        filtered = [
            f
            for f in filtered
            if any(token in f.lower() for token in ctx.framework_filters)
        ]
    return filtered


def merge_directories(src: Path, dest: Path) -> None:
    dest.mkdir(parents=True, exist_ok=True)
    for entry in src.iterdir():
        target = dest / entry.name
        if entry.is_dir():
            merge_directories(entry, target)
            try_remove_empty(entry)
        else:
            if target.exists():
                entry.unlink()
            else:
                shutil.move(str(entry), str(target))
    try_remove_empty(src)


def try_remove_empty(path: Path) -> None:
    try:
        path.rmdir()
    except OSError:
        return


def try_remove_file(path: Path) -> None:
    try:
        path.unlink()
    except FileNotFoundError:
        return
    except IsADirectoryError:
        shutil.rmtree(path, ignore_errors=True)


def normalize_framework_name(name: str) -> str:
    trimmed = name.strip()
    if not trimmed:
        return trimmed
    return trimmed if trimmed.endswith(".framework") else f"{trimmed}.framework"


def resolve_skip_existing(args) -> bool:
    if getattr(args, "force", False):
        return False
    env_force = os.getenv("PH_FORCE")
    if env_force == "1":
        return False
    env_value = os.getenv("PH_SKIP_EXISTING")
    if env_value is not None:
        return env_value == "1"
    return True


def resolve_rebuild_classdump(args) -> bool:
    if getattr(args, "rebuild_classdump", False):
        return True
    env_value = os.getenv("PH_REBUILD_CLASSDUMP")
    return env_value == "1"


def resolve_shared_cache(args) -> bool:
    if getattr(args, "shared_cache", False):
        return True
    env_value = os.getenv("PH_SHARED_CACHE")
    if env_value is not None:
        return env_value == "1"
    return True


def resolve_verbose(args) -> bool:
    if getattr(args, "verbose", False):
        return True
    env_value = os.getenv("PH_VERBOSE")
    if env_value is not None:
        return env_value == "1"
    return False


def needs_split(ctx: Context) -> bool:
    return bool(
        ctx.exec_mode == "simulator"
        or ctx.framework_names
        or ctx.framework_filters
        or ctx.skip_existing
    )


def run_capture_command(cmd: str, args: list[str]) -> str:
    result = subprocess.run(
        [cmd, *args], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )
    if result.returncode != 0:
        raise RuntimeError(f"{cmd} failed: {result.stderr.strip()}")
    return result.stdout


def run_simple_command(cmd: str, args: list[str], err: str, cwd: Path | None = None) -> None:
    result = subprocess.run([cmd, *args], cwd=str(cwd) if cwd else None)
    if result.returncode != 0:
        raise RuntimeError(err)


def read_line(prompt: str) -> str:
    try:
        return input(prompt).strip()
    except EOFError:
        return ""


def version_key(version: str) -> tuple[int, ...]:
    parts = []
    for part in version.split("."):
        try:
            parts.append(int(part))
        except ValueError:
            parts.append(0)
    return tuple(parts)


if __name__ == "__main__":
    raise SystemExit(main())
